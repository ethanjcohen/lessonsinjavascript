{"name":"Lessons In JavaScript","tagline":"This contains lessons discussing some of the complicated concepts in JavaScript, in an effort to transition Java developers to JavaScript.","body":"Lessons In JavaScript\r\n===================\r\n\r\n<h2>Lesson 1: Callback Basics</h2>\r\n\r\n<h3>What's a callback?</h3>\r\nA callback is nothing more than a function that you pass to another function as an argument or parameter.\r\n\r\nLet's look at a very simple example of using a callback design pattern.\r\n\r\nThe following function takes two numbers as parameters and returns the sum:\r\n```javascript\r\nfunction sum(numberOne, numberTwo)\r\n{\r\n\tvar value = numberOne + numberTwo;\r\n\treturn value;\r\n}\r\n\r\nvar value = sum(2, 5); //value is 7\r\n```\r\n\r\nYou can rewrite that function using the callback design pattern:\r\n```javascript\r\nfunction sum(numberOne, numberTwo, callbackFunction)\r\n{\r\n\tvar value = numberOne + numberTwo;\r\n\tcallbackFunction(value);\r\n}\r\n\r\nvar value = null;\r\n\r\nsum(2, 5, function(result)\r\n{\r\n\t//result is 7\r\n\tvalue = result;\r\n});\r\n```\r\n\r\nSee the difference? The two pieces of code above do exactly the same thing, but the second uses a callback. Using a callback for this example is obviously not needed, but that's not the point.\r\n\r\n\r\n<h3>The problem with synchronous (linear) code in javaScript</h3>\r\nA lot of Java developers have trouble grasping the asyncronous nature of JavaScript. In Java server-side code, to retrieve data from a web service you might do something like this:\r\n```java\r\nString xmlResponse = getDataFromWebService();\r\nSystem.out.println(xmlResponse);\r\n```\r\n\r\nIf we implement our code this way in JavaScript, the browser will be hung while we are waiting for data to be returned from the web service.\r\n\r\nWhy? Because the browser will not update the screen (the DOM elements) while JavaScript is running.\r\n\r\nThink about that: nothing will update on the UI until your JavaScript has finished executing!\r\n\r\nTake this example in JavaScript:\r\n\r\n```javascript\r\nfunction updateView(text)\r\n{\r\n\t$('#output').text(text);\r\n}\r\n\r\nupdateView('Loading...');\r\nvar xmlData = getDataFromWebService();\r\nupdateView(xmlData);\r\n```\r\n\r\nWe want to show \"Loading...\" on the screen, and then replace that with the response from the web service. \r\n\r\nUnfortunately, \"Loading...\" will not be rendered on the screen until the JavaScript has finished executing. If the web service takes 2 minutes to return, the user will be stuck looking at a blank screen for 2 minutes!\r\n\r\nHere's what actually happens:\r\n<ol>\r\n\t<li>updateView is called</li>\r\n\t<li>The browser adds an event to it's queue to update the UI</li>\r\n\t<li>getDataFromWebService is called</li>\r\n\t<li>A request is sent to the web service</li>\r\n\t<li>The web service returns a response</li>\r\n\t<li>The value of xmlData is set to the xml response</li>\r\n\t<li>updateView is called</li>\r\n\t<li>The browser adds an event to it's queue to update the UI</li>\r\n\t<li>The browser updates the view with \"Loading...\"</li>\r\n\t<li>The browser updates the view with the value of xmlData</li>\r\n</ol>\r\n\r\nThe user will see a white screen for 2 minutes, then the xml. The user will never see \"Loading...\"\r\n\r\n<h3>The right way: use callbacks</h3>\r\n\r\nTake a look at the above example re-written using a callback design pattern:\r\n\r\n```javascript\r\nfunction updateView(text)\r\n{\r\n\t$('#output').text(text);\r\n}\r\n\r\nupdateView('Loading...');\r\ngetDataFromWebService(function(xmlData) //create an anonymous function to pass in as a parameter\r\n{\r\n\tupdateView(xmlData);\r\n});\r\n```\r\n\r\nIn the above example, we assume that the function <b>getDataFromWebService</b> takes one parameter, a function. When <b>getDataFromWebService</b> has retrieved the web service data, it will execute the function, passing the xml data to it.\r\n\r\nThe above example was implemented using an anonymous function (a function that has no name), which you'll often see in JavaScript code.\r\n\r\nAnother way to write this example:\r\n\r\n```javascript\r\nfunction updateView(text)\r\n{\r\n\t$('#output').text(text);\r\n}\r\n\r\nupdateView('Loading...');\r\ngetDataFromWebService(updateView); //pass in the callback function as a parameter\r\n```\r\n\r\n<h3>Callbacks are are great for event-driven design</h3>\r\n\r\njQuery uses a lot of callbacks to connect a function with an event. Take this simple example:\r\n```javascript\r\n$('button').on('click', function()\r\n{\r\n\talert(\"The button was clicked!\");\r\n});\r\n```\r\nIn the above example, every time the user clicks a button on the web page, a message will be shown. The first parameter to the <b>on</b> function is a string, the event name, and the second parameter is a callback function to execute when that event occurs.\r\n\r\n<h2>Lesson 2: Async Program Flow</h2>\r\n\r\n<h3>Linear Operations with Nested Callbacks</h3>\r\nAgain, let's take a simplified Java server-side code block that calls multiple web services from some API.\r\n```java\r\nInteger userID = getActiveUser();\r\nArray friendsArray = getFriendsOfUser(userID);\r\nSystem.out.println(\"The user has \" + friendsArray.length + \" friends.\");\r\n```\r\n\r\nThis is how that example would look with callbacks in JavaScript:\r\n```javascript\r\ngetActiveUser(function(userID)\r\n{\r\n\tgetFriendsOfUser(userID, function(friendsArray){\r\n\t\tconsole.log(\"The user has \" + friendsArray.length + \" friends.\");\r\n\t});\r\n});\r\n```\r\n\r\nIn both examples above:\r\nThe function <b>getActiveUser</b> is executed first. When that function returns the user's ID, the function <b>getFriendsOfUser</b> is executed. Then when that function returns the array of friends, the number of friends is displayed.\r\n\r\nLet's make it slightly more complicated by adding one more function...\r\n\r\nIn Java:\r\n```java\r\nInteger userID = getActiveUser();\r\nArray friendsArray = getFriendsOfUser(userID);\r\nBoolean sent = sendMessageToUsers(userID, friendsArray, \"Hello\");\r\nSystem.out.println(\"The messages were sent: \" + sent);\r\n```\r\n\r\nIn JavaScript:\r\n```javascript\r\ngetActiveUser(function(userID)\r\n{\r\n\tgetFriendsOfUser(userID, function(friendsArray){\r\n\t\tsendMessageToUsers(userID, friendsArray, \"Hello\", function(sent)\r\n\t\t{\r\n\t\t\tconsole.log(\"The messages were sent: \" + sent);\r\n\t\t});\r\n\t});\r\n});\r\n```\r\n\r\n<h3>Async Functions in For Loops</h3>\r\nLet's say we need to make multiple calls to a web service, and then do something afterwards. Assume for this example that we have two user IDs and a function <b>sendMessage</b> that sends a message to a single user.\r\n\r\nTo send a message to those users, we could write our JavaScript like this:\r\n```javascript\r\nsendMessage(userID_A, \"Hello\", function()\r\n{\r\n\tsendMessage(userID_B, \"Hello\", function()\r\n\t{\r\n\t\tconsole.log(\"sent messages\");\r\n\t});\r\n});\r\n```\r\n\r\nThis is a very clean way to structure our code. It will send \"Hello\" to userA first, then send a message \"Hello\" to userB and finally show \"sent messages.\"\r\n\r\nBut what if you had to send messages to 5 users? or 10? or 100? Should we still use nested callbacks like this? No - that would be impossible to read.\r\n\r\nI see a lot of developers try to write something like this:\r\n```javascript\r\nvar userIDs = [....]; //an array of X length\r\n\r\nfor(var i=0; i<userIDs.length; i++)\r\n{\r\n\tvar userID = userIDs[i];\r\n\tsendMessage(userID_B, \"Hello\", function()\r\n\t{\r\n\t\tconsole.log(\"sent one message\");\r\n\t});\r\n}\r\n\r\nconsole.log(\"sent messages\");\r\n```\r\n\r\nHere's what will happen at runtime:\r\n<ol>\r\n<li>X requests will be made to the <b>sendMessage</b> web service</li>\r\n<li>The console will log \"sent messages\"</li>\r\n<li>X responses will return (at some time), followed by the log \"sent one message\"</li>\r\n</ol>\r\n\r\nNotice what's happening here: the final log is executing after the requests to the web service have been made, NOT after the responses have returned. We want all X responses to return and then to log \"sent messages.\" Here's how:\r\n\r\nA simple solution to this is creating one more function and a counter equal to the number of asyncronous calls:\r\n```javascript\r\nvar messagesToSend = userIDs.length;\r\nfunction sentMessage()\r\n{\r\n\tmessagesToSend--;\r\n\tif(messagesToSend == 0)\r\n\t{\r\n\t\t//all web service responses have been received!\r\n\t\tconsole.log(\"sent messages\");\r\n\t}\r\n}\r\n```\r\n\r\nThis function will be called every time <b>sendMessage</b> executes it's callback. It will only execute the final log, after it has been called X times.\r\n\r\nHere's the correct way to structure this code:\r\n```javascript\r\nvar userIDs = [....]; //an array of unknown or large size\r\nvar messagesToSend = userIDs.length;\r\n\r\nfor(var i=0; i<userIDs.length; i++)\r\n{\r\n\tvar userID = userIDs[i];\r\n\tsendMessage(userID_B, \"Hello\", sentMessage);\r\n}\r\n\r\nfunction sentMessage()\r\n{\r\n\tconsole.log(\"sent one message\");\r\n\t\r\n\tmessagesToSend--;\r\n\tif(messagesToSend == 0)\r\n\t{\r\n\t\t//all web service responses have been received!\r\n\t\tconsole.log(\"sent messages\");\r\n\t}\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}